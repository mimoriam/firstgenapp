import 'dart:convert';
import 'dart:developer';
import 'dart:io';
import 'dart:async';
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:firebase_database/firebase_database.dart' hide Query;
import 'package:firstgenapp/models/chat_models.dart';
import 'package:firstgenapp/services/continent_service.dart';
import 'package:firstgenapp/utils/authException.dart';
import 'package:google_sign_in/google_sign_in.dart';
import 'dart:math' hide log;

class FirebaseService {
  final FirebaseAuth _auth = FirebaseAuth.instance;
  final GoogleSignIn _googleSignIn = GoogleSignIn();
  final FirebaseFirestore _firestore = FirebaseFirestore.instance;
  final FirebaseDatabase _database = FirebaseDatabase.instance;

  Stream<User?> get authStateChanges => _auth.authStateChanges();
  User? get currentUser => _auth.currentUser;

  final userCollection = "users";

  // Email/Password Login
  Future<UserCredential> loginWithEmail({
    required String email,
    required String password,
  }) async {
    try {
      return await _auth.signInWithEmailAndPassword(
        email: email,
        password: password,
      );
    } on FirebaseAuthException catch (e) {
      log('FirebaseAuthException in login: ${e.code}', error: e);
      throw _handleAuthException(e);
    } catch (e) {
      log('An unexpected error occurred in login', error: e);
      throw AuthException('An unexpected error occurred. Please try again.');
    }
  }

  // Email/Password Registration
  Future<UserCredential> signUpWithEmail({
    required String email,
    required String password,
    required String fullName,
  }) async {
    try {
      final UserCredential userCredential = await _auth
          .createUserWithEmailAndPassword(email: email, password: password);

      //Update the user's display name
      // The user object is available on the returned UserCredential
      if (userCredential.user != null) {
        await userCredential.user!.updateDisplayName(fullName);
      }

      return userCredential;
    } on FirebaseAuthException catch (e) {
      log('FirebaseAuthException in signUp: ${e.code}', error: e);
      throw _handleAuthException(e);
    } catch (e) {
      log('An unexpected error occurred in signUp', error: e);
      throw AuthException('An unexpected error occurred. Please try again.');
    }
  }

  Future<UserCredential> signInWithGoogle() async {
    try {
      final GoogleSignInAccount? googleUser = await _googleSignIn.signIn();

      // The user canceled the sign-in flow
      if (googleUser == null) {
        throw AuthException('Google Sign-In was cancelled by the user.');
      }

      final GoogleSignInAuthentication googleAuth =
          await googleUser.authentication;

      final AuthCredential credential = GoogleAuthProvider.credential(
        accessToken: googleAuth.accessToken,
        idToken: googleAuth.idToken,
      );

      return await _auth.signInWithCredential(credential);
    } on FirebaseAuthException catch (e) {
      // Let the handler create the appropriate exception for the UI layer
      throw _handleAuthException(e);
    } catch (e) {
      log('An unexpected error occurred during Google Sign-In: $e');
      throw AuthException('An unexpected Google Sign-In error occurred.');
    }
  }

  // Links a pending credential (from Google) to an existing email/password account.
  // The UI should call this after catching the 'account-exists-with-different-credential'
  // exception and securely getting the user's password.
  Future<UserCredential> linkCredentials({
    required String email,
    required String password,
    required AuthCredential credentialToLink,
  }) async {
    try {
      // Re-authenticate the user with their original provider (email/password) to prove they own the account.
      final userCredential = await _auth.signInWithEmailAndPassword(
        email: email,
        password: password,
      );

      // If re-authentication is successful, link the new credential.
      return await userCredential.user!.linkWithCredential(credentialToLink);
    } on FirebaseAuthException catch (e) {
      throw _handleAuthException(e);
    } catch (e) {
      log('An unexpected error occurred during account linking: $e');
      throw AuthException(
        'An unexpected error occurred while linking accounts.',
      );
    }
  }

  Future<void> signOut() async {
    try {
      await _googleSignIn.signOut();
      await _auth.signOut();
    } catch (e) {
      log('Unexpected error during sign out: $e');
      throw AuthException('Sign out failed. Please try again.');
    }
  }

  Future<bool> checkIfEmailInUse(String email) async {
    try {
      await _auth.createUserWithEmailAndPassword(
        email: email,
        password: "a-dummy-password-for-checking",
      );

      await _auth.currentUser?.delete();
      return false; // Email did not exist.
    } on FirebaseAuthException catch (e) {
      if (e.code == 'email-already-in-use') {
        // This is the primary success case for our check, meaning the email exists.
        return true;
      }
      if (e.code == 'weak-password') {
        // This is an expected failure if the email does NOT exist.
        return false;
      }
      // Handle other potential errors during the check, assuming email is not in use.
      log('FirebaseAuthException while checking email: ${e.code}');
      return false;
    } catch (e) {
      log('An unexpected error occurred while checking email: $e');
      return false;
    }
  }

  Future<void> createUserDocument(
    String userId,
    Map<String, dynamic> data,
  ) async {
    try {
      await _firestore.collection(userCollection).doc(userId).set(data);
    } on FirebaseException catch (e) {
      log('FirebaseException in createUserDocument: ${e.code}', error: e);
      throw Exception('Failed to create user profile in the database.');
    } catch (e) {
      log('An unexpected error occurred in createUserDocument', error: e);
      throw Exception(
        'An unexpected error occurred while saving your profile.',
      );
    }
  }

  // MODIFICATION: Added a method to check if the user's profile document exists in Firestore.
  Future<bool> isUserProfileComplete(String userId) async {
    try {
      final docSnapshot = await _firestore
          .collection(userCollection)
          .doc(userId)
          .get();
      return docSnapshot.exists;
    } catch (e) {
      log('Error checking user profile completeness: $e');
      return false; // Assume not complete on error
    }
  }

  Future<String> uploadProfileImage(String userId, File image) async {
    try {
      // final ref = _storage.ref().child('profile_images').child('$userId.jpg');
      // await ref.putFile(image);
      // return await ref.getDownloadURL();

      return "image.png";
    } on FirebaseException catch (e) {
      log('FirebaseException in uploadProfileImage: ${e.code}', error: e);
      throw Exception('Failed to upload profile image.');
    } catch (e) {
      log('An unexpected error occurred in uploadProfileImage', error: e);
      throw Exception(
        'An unexpected error occurred while uploading your image.',
      );
    }
  }

  Future<DocumentSnapshot<Map<String, dynamic>>?> getUserProfile() async {
    final user = _auth.currentUser;
    if (user == null) return null;

    try {
      final docSnapshot = await _firestore
          .collection(userCollection)
          .doc(user.uid)
          .get();
      if (docSnapshot.exists) {
        return docSnapshot;
      } else {
        log('User document does not exist for uid: ${user.uid}');
        return null;
      }
    } on FirebaseException catch (e) {
      log('FirebaseException in getUserProfile: ${e.code}', error: e);
      throw Exception('Failed to fetch user profile.');
    } catch (e) {
      log('An unexpected error occurred in getUserProfile', error: e);
      throw Exception(
        'An unexpected error occurred while fetching your profile.',
      );
    }
  }

  Stream<DocumentSnapshot<Map<String, dynamic>>> getUserProfileStream() {
    final user = _auth.currentUser;
    if (user == null) {
      // Return a stream that emits an error if the user is not logged in.
      return Stream.error('User not logged in');
    }
    return _firestore.collection(userCollection).doc(user.uid).snapshots();
  }

  Future<void> updateUserProfile(Map<String, dynamic> data) async {
    final user = _auth.currentUser;
    if (user == null) return;

    try {
      // Ensure the full name in Auth is also updated if it has changed.
      if (data.containsKey('fullName') &&
          user.displayName != data['fullName']) {
        await user.updateDisplayName(data['fullName']);
      }

      // MODIFICATION: If the country is being updated, also update the continent.
      if (data.containsKey('culturalHeritage')) {
        final countryCode = data['culturalHeritage'];
        data['continent'] = ContinentService.getContinent(countryCode);
      }

      await _firestore.collection(userCollection).doc(user.uid).update(data);
    } on FirebaseException catch (e) {
      log('FirebaseException in updateUserProfile: ${e.code}', error: e);
      throw Exception('Failed to update user profile.');
    } catch (e) {
      log('An unexpected error occurred in updateUserProfile', error: e);
      throw Exception(
        'An unexpected error occurred while updating your profile.',
      );
    }
  }

  Future<List<QueryDocumentSnapshot<Map<String, dynamic>>>>
  getAllUsers() async {
    try {
      final user = _auth.currentUser;
      if (user == null) return [];

      final querySnapshot = await _firestore
          .collection(userCollection)
          // Optionally, you might want to exclude the current user from the list.
          .where('uid', isNotEqualTo: user.uid)
          .get();

      return querySnapshot.docs;
    } catch (e) {
      log('Error getting all users: $e');
      return [];
    }
  }

  Future<List<QueryDocumentSnapshot<Map<String, dynamic>>>> searchUsers({
    required String country,
    required List<String> languages,
    String? generation,
    String? gender,
    required int minAge,
    required int maxAge,
    required List<String> professions,
    required List<String> interests,
  }) async {
    try {
      final user = _auth.currentUser;
      if (user == null) return [];

      // Start with a base query
      Query<Map<String, dynamic>> query = _firestore
          .collection(userCollection)
          .where('uid', isNotEqualTo: user.uid);

      // Apply filters. Note: Firestore has limitations on complex queries.
      // This implementation uses multiple 'where' clauses. For more complex
      // scenarios, you might need to perform some filtering on the client-side.

      query = query.where('culturalHeritage', isEqualTo: country);

      if (generation != null) {
        query = query.where('generation', isEqualTo: generation);
      }
      if (gender != null) {
        query = query.where('gender', isEqualTo: gender);
      }
      if (languages.isNotEmpty) {
        query = query.where('languages', arrayContainsAny: languages);
      }
      if (professions.isNotEmpty) {
        query = query.where('profession', whereIn: professions);
      }
      if (interests.isNotEmpty) {
        query = query.where('hobbies', whereIn: interests);
      }

      final querySnapshot = await query.get();

      // Client-side filtering for age, as Firestore does not support range queries on different fields.
      final now = DateTime.now();
      final minDob = DateTime(now.year - maxAge, now.month, now.day);
      final maxDob = DateTime(now.year - minAge, now.month, now.day);

      final filteredDocs = querySnapshot.docs.where((doc) {
        final dobTimestamp = doc.data()['dateOfBirth'] as Timestamp?;
        if (dobTimestamp == null) return false;
        final dob = dobTimestamp.toDate();
        return dob.isAfter(minDob) && dob.isBefore(maxDob);
      }).toList();

      return filteredDocs;
    } catch (e) {
      log('Error searching users: $e');
      return [];
    }
  }

  // Password Reset
  Future<void> sendPasswordResetEmail(String email) async {
    try {
      await _auth.sendPasswordResetEmail(email: email);
    } on FirebaseAuthException catch (e) {
      log('FirebaseAuthException in password reset: ${e.code}', error: e);
      throw _handleAuthException(e);
    } catch (e) {
      log('An unexpected error occurred in password reset', error: e);
      throw AuthException(
        'An unexpected error occurred. Please try again later.',
      );
    }
  }

  Future<List<QueryDocumentSnapshot<Map<String, dynamic>>>> searchUsersStrict({
    String? continent,
    List<String>? languages,
    String? generation,
    String? gender,
    int? minAge,
    int? maxAge,
    List<String>? professions,
    List<String>? interests,
  }) async {
    final user = _auth.currentUser;
    if (user == null) return [];

    // Start with a base query that excludes the current user.
    Query<Map<String, dynamic>> query = _firestore
        .collection(userCollection)
        .where('uid', isNotEqualTo: user.uid);

    // Apply strict AND filters for core preferences on the server-side.
    if (continent != null && continent != 'Global') {
      query = query.where('continent', isEqualTo: continent);
    }
    if (generation != null) {
      query = query.where('generation', isEqualTo: generation);
    }
    // FIX: Check for 'Other' and skip the gender filter if it's selected.
    if (gender != null && gender != 'Other') {
      query = query.where('gender', isEqualTo: gender);
    }

    try {
      final querySnapshot = await query.get();
      List<QueryDocumentSnapshot<Map<String, dynamic>>> results =
          querySnapshot.docs;

      // === Start Client-Side Filtering for remaining AND conditions ===

      // 1. Filter by Age (Strict AND)
      if (minAge != null && maxAge != null) {
        final now = DateTime.now();
        final minDob = DateTime(now.year - maxAge, now.month, now.day);
        final maxDob = DateTime(now.year - minAge, now.month, now.day);

        results = results.where((doc) {
          final dobTimestamp = doc.data()['dateOfBirth'] as Timestamp?;
          if (dobTimestamp == null) return false;
          final dob = dobTimestamp.toDate();
          return dob.isAfter(minDob) && dob.isBefore(maxDob);
        }).toList();
      }

      // 2. Filter by Languages (Strict AND)
      if (languages != null && languages.isNotEmpty) {
        results = results.where((doc) {
          final userLanguages = List<String>.from(
            doc.data()['languages'] ?? [],
          );
          return languages.every((lang) => userLanguages.contains(lang));
        }).toList();
      }

      // === End Client-Side AND Filtering ===

      // === Start Client-Side OR Filtering for optional criteria ===

      final bool hasOrFilters =
          (professions?.isNotEmpty ?? false) ||
          (interests?.isNotEmpty ?? false);

      if (hasOrFilters) {
        results = results.where((doc) {
          final data = doc.data();

          if (professions?.isNotEmpty ?? false) {
            final userProfession = data['profession'] as String?;
            if (userProfession != null &&
                professions!.contains(userProfession)) {
              return true;
            }
          }

          if (interests?.isNotEmpty ?? false) {
            final userHobbiesString = data['hobbies'] as String?;
            if (userHobbiesString != null) {
              final userInterests = userHobbiesString
                  .split(',')
                  .map((e) => e.trim())
                  .toList();
              if (interests!.any(
                (interest) => userInterests.contains(interest),
              )) {
                return true;
              }
            }
          }

          return false;
        }).toList();
      }

      return results;
    } catch (e) {
      log('Error searching users: $e');
      return [];
    }
  }

  // CHAT FUNCTIONALITY
  Future<void> createChat(ChatUser otherUser) async {
    final currentUser = await getCurrentChatUser();
    if (currentUser == null) return;

    final conversationId = getConversationId(currentUser.uid, otherUser.uid);
    final now = DateTime.now().toUtc().toIso8601String();

    final conversationData = {
      'participants': {currentUser.uid: true, otherUser.uid: true},
      'lastMessage': '',
      'lastMessageTimestamp': now,
      'users': {
        currentUser.uid: currentUser.toJson(),
        otherUser.uid: otherUser.toJson(),
      },
      'unreadCount': {currentUser.uid: 0, otherUser.uid: 0},
      'lastMessageSenderId': '',
    };

    await _database.ref('conversations/$conversationId').set(conversationData);
    await _database
        .ref('users/${currentUser.uid}/conversations/$conversationId')
        .set(true);
    await _database
        .ref('users/${otherUser.uid}/conversations/$conversationId')
        .set(true);
  }

  Stream<List<Conversation>> getConversations() {
    final currentUser = _auth.currentUser;
    if (currentUser == null) return Stream.value([]);

    final userConversationsRef = _database.ref('users/${currentUser.uid}/conversations');

    return userConversationsRef.onValue.transform(
      StreamTransformer<DatabaseEvent, List<Conversation>>.fromHandlers(
        handleData: (DatabaseEvent event, EventSink<List<Conversation>> sink) async {
          if (event.snapshot.value == null) {
            sink.add([]);
            return;
          }

          final conversationIdsMap = event.snapshot.value as Map;
          final conversationIds = conversationIdsMap.keys.toList();
          final conversations = <Conversation>[];

          for (var id in conversationIds) {
            final snapshot = await _database.ref('conversations/$id').get();
            if (snapshot.exists && snapshot.value != null) {
              final encodedData = jsonEncode(snapshot.value);
              final data = jsonDecode(encodedData) as Map<String, dynamic>;
              conversations.add(
                Conversation.fromJson(data, id.toString(), currentUser.uid),
              );
            }
          }

          conversations.sort(
            (a, b) => b.lastMessageTimestamp.compareTo(a.lastMessageTimestamp),
          );
          sink.add(conversations);
        },
      ),
    );
  }

  Future<void> addRecentMatch(String otherUserId) async {
    final currentUser = _auth.currentUser;
    if (currentUser == null) return;

    // Add other user to current user's recent matches
    await _updateRecentMatchesForUser(currentUser.uid, otherUserId);

    // Add current user to other user's recent matches
    await _updateRecentMatchesForUser(otherUserId, currentUser.uid);
  }

  Future<void> _updateRecentMatchesForUser(
    String userId,
    String matchId,
  ) async {
    final recentMatchesRef = _database.ref('users/$userId/recent_matches');
    final snapshot = await recentMatchesRef.get();

    List<dynamic> recentMatches = [];
    if (snapshot.exists && snapshot.value is List) {
      recentMatches = List<dynamic>.from(snapshot.value as List);
    }

    // Remove if it exists to re-add it at the end (most recent)
    recentMatches.remove(matchId);
    recentMatches.add(matchId);

    // Keep only the 6 most recent matches
    if (recentMatches.length > 6) {
      recentMatches = recentMatches.sublist(recentMatches.length - 6);
    }

    await recentMatchesRef.set(recentMatches);
  }

  Future<void> addRecentUser(String userId) async {
    final currentUser = _auth.currentUser;
    if (currentUser == null) {
      return;
    }
    await addRecentMatch(userId);
  }

  // FIX: Modified to return user UID for chat functionality.
  Future<List<Map<String, dynamic>>> getRecentUsers() async {
    final user = _auth.currentUser;
    if (user == null) return [];

    try {
      final recentMatchesRef = _database.ref(
        'users/${user.uid}/recent_matches',
      );
      final snapshot = await recentMatchesRef.get();

      if (!snapshot.exists || snapshot.value == null) {
        return [];
      }

      final recentMatchIds = List<String>.from(
        (snapshot.value as List).map((e) => e.toString()),
      );

      if (recentMatchIds.isEmpty) {
        return [];
      }

      // Fetch user profiles from Firestore based on the UIDs from Realtime DB
      final querySnapshot = await _firestore
          .collection(userCollection)
          .where('uid', whereIn: recentMatchIds)
          .get();

      // To maintain the order from recent_matches
      final orderedDocs = <Map<String, dynamic>>[];
      // We iterate in reverse to get the most recent matches first.
      for (final userId in recentMatchIds.reversed) {
        final doc = querySnapshot.docs.firstWhere(
          (d) => d.id == userId,
          orElse: () => throw Exception("User not found"),
        );
        orderedDocs.add({
          'uid': doc.id, // Add UID
          'name': doc.data()['fullName'] as String? ?? 'No Name',
          'avatar':
              doc.data()['profileImageUrl'] as String? ??
              'https://picsum.photos/seed/${doc.data()['uid']}/200/200',
        });
      }

      return orderedDocs;
    } catch (e) {
      log('Error getting recent users: $e');
      return [];
    }
  }

  Stream<List<ChatMessage>> getMessages(String conversationId) {
    return _database
        .ref('messages/$conversationId')
        .orderByChild('timestamp')
        .onValue
        .map((event) {
          if (event.snapshot.value == null) {
            return [];
          }
          // FIX: Use jsonEncode/Decode here as well
          final encodedData = jsonEncode(event.snapshot.value);
          final messagesMap = jsonDecode(encodedData) as Map<String, dynamic>;
          final messages = messagesMap.entries
              .map(
                (e) => ChatMessage.fromJson(
                  Map<String, dynamic>.from(e.value as Map),
                  e.key,
                ),
              )
              .toList();
          messages.sort((a, b) => a.timestamp.compareTo(b.timestamp));
          return messages;
        });
  }

  Future<void> sendMessage(String conversationId, String text) async {
    final currentUser = _auth.currentUser;
    if (currentUser == null) return;

    final messageId = _database.ref().push().key;
    final now = DateTime.now().toUtc().toIso8601String();

    final message = ChatMessage(
      id: messageId!,
      text: text,
      senderId: currentUser.uid,
      timestamp: now,
    );

    await _database
        .ref('messages/$conversationId/$messageId')
        .set(message.toJson());

    final conversationRef = _database.ref('conversations/$conversationId');
    final snapshot = await conversationRef.get();
    if (snapshot.exists) {
      final data = Map<String, dynamic>.from(snapshot.value as Map);
      final participants = Map<String, dynamic>.from(
        data['participants'] as Map,
      );
      final otherUserId = participants.keys.firstWhere(
        (id) => id != currentUser.uid,
      );

      conversationRef.update({
        'lastMessage': text,
        'lastMessageTimestamp': now,
        'lastMessageSenderId': currentUser.uid,
      });
      conversationRef
          .child('unreadCount/$otherUserId')
          .set(ServerValue.increment(1));
    }
  }

  Future<void> markAsRead(String conversationId) async {
    final currentUser = _auth.currentUser;
    if (currentUser == null) return;
    await _database
        .ref('conversations/$conversationId/unreadCount/${currentUser.uid}')
        .set(0);
  }

  Future<ChatUser?> getCurrentChatUser() async {
    final user = _auth.currentUser;
    if (user == null) return null;
    final profile = await getUserProfile();
    if (profile == null) return null;
    return ChatUser(
      uid: user.uid,
      name: profile.data()?['fullName'] ?? 'No Name',
      avatarUrl:
          profile.data()?['profileImageUrl'] ??
          'https://picsum.photos/seed/${Random().nextInt(1000)}/200/200',
    );
  }

  String getConversationId(String uid1, String uid2) {
    return uid1.hashCode <= uid2.hashCode ? '$uid1-$uid2' : '$uid2-$uid1';
  }

  // FIX: New method to get or create a conversation
  Future<Conversation> getOrCreateConversation(String otherUserId) async {
    final currentUser = _auth.currentUser;
    if (currentUser == null) throw Exception("User not logged in");

    final conversationId = getConversationId(currentUser.uid, otherUserId);
    final conversationRef = _database.ref('conversations/$conversationId');

    final snapshot = await conversationRef.get();
    if (!snapshot.exists) {
      // Conversation doesn't exist, create it.
      final otherUserDoc = await _firestore
          .collection(userCollection)
          .doc(otherUserId)
          .get();
      if (!otherUserDoc.exists) {
        throw Exception("Other user profile not found");
      }

      final otherUserData = otherUserDoc.data()!;
      final otherUser = ChatUser(
        uid: otherUserId,
        name: otherUserData['fullName'] ?? 'No Name',
        avatarUrl:
            otherUserData['profileImageUrl'] ??
            'https://picsum.photos/seed/$otherUserId/200/200',
      );
      await createChat(otherUser);
    }

    // Fetch the (now existing) conversation data
    final finalSnapshot = await conversationRef.get();
    final encodedData = jsonEncode(finalSnapshot.value);
    final data = jsonDecode(encodedData) as Map<String, dynamic>;

    return Conversation.fromJson(data, conversationId, currentUser.uid);
  }

  /// Maps [FirebaseAuthException] codes to user-friendly [AuthException] objects.
  AuthException _handleAuthException(FirebaseAuthException e) {
    log('FirebaseAuthException: code=${e.code}, message=${e.message}');
    String message;
    switch (e.code) {
      case 'user-not-found':
        message = 'No user found for that email.';
        break;
      case 'wrong-password':
        message = 'Incorrect password. Please try again.';
        break;
      case 'email-already-in-use':
        message = 'An account already exists for that email.';
        break;
      case 'weak-password':
        message = 'The password provided is too weak.';
        break;
      case 'invalid-email':
        message = 'The email address is not valid.';
        break;
      case 'invalid-credential':
        message = "Wrong email/password combination.";
        break;
      case 'user-disabled':
        message = 'This user account has been disabled.';
        break;
      case 'too-many-requests':
        message =
            'Access to this account has been temporarily disabled due to many failed login attempts. You can immediately restore it by resetting your password or you can try again later.';
        break;
      case 'network-request-failed':
        message = 'Network error. Please check your connection and try again.';
        break;
      case 'account-exists-with-different-credential':
        message = 'An account already exists with this email address.';
        break;
      default:
        message = 'An unknown authentication error occurred.';

    }
    return AuthException(message, code: e.code);
  }
}

```dart:lib/screens/dashboard/navbar_content/chats/chats_screen.dart
import 'package:firstgenapp/models/chat_models.dart';
import 'package:firstgenapp/screens/dashboard/navbar_content/chats/conversation/conversation_screen.dart';
import 'package:firstgenapp/services/firebase_service.dart';
import 'package:firstgenapp/utils/time_ago.dart';
import 'package:flutter/material.dart';
import 'package:firstgenapp/constants/appColors.dart';
import 'package:iconly/iconly.dart';
import 'package:iconsax_flutter/iconsax_flutter.dart';
import 'package:persistent_bottom_nav_bar/persistent_bottom_nav_bar.dart';
import 'package:provider/provider.dart';

// FIX: Converted to StatefulWidget to handle refresh.
class ChatsScreen extends StatefulWidget {
  const ChatsScreen({super.key});

  @override
  State<ChatsScreen> createState() => _ChatsScreenState();
}

class _ChatsScreenState extends State<ChatsScreen> {
  // FIX: Added keys to force child widgets to rebuild on refresh.
  Key _recentMatchesKey = UniqueKey();
  Key _conversationsKey = UniqueKey();

  Future<void> _handleRefresh() async {
    // This will cause the children with these keys to be rebuilt, re-triggering their futures/streams.
    setState(() {
      _recentMatchesKey = UniqueKey();
      _conversationsKey = UniqueKey();
    });
  }

  @override
  Widget build(BuildContext context) {
    final textTheme = Theme.of(context).textTheme;

    return Scaffold(
      backgroundColor: AppColors.primaryBackground,
      appBar: AppBar(
        backgroundColor: AppColors.primaryBackground,
        elevation: 0,
        scrolledUnderElevation: 0,
        title: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text('Talk Time!', style: textTheme.headlineSmall),
            const SizedBox(height: 4),
            Text(
              'Catch up, connect, and keep the story going.',
              style: textTheme.bodySmall,
            ),
          ],
        ),
        actions: [
          IconButton(
            onPressed: () {},
            icon: const Icon(
              IconlyLight.search,
              color: AppColors.textSecondary,
              size: 24,
            ),
          ),
        ],
      ),
      // FIX: Added RefreshIndicator to allow pull-to-refresh.
      body: RefreshIndicator(
        onRefresh: _handleRefresh,
        child: ListView(
          padding: const EdgeInsets.symmetric(horizontal: 16.0),
          children: [
            const SizedBox(height: 16),
            _buildSectionHeader('Recent match', textTheme),
            const SizedBox(height: 12),
            RecentMatchesList(key: _recentMatchesKey),
            const SizedBox(height: 20),
            _buildSectionHeader('Messages', textTheme),
            const SizedBox(height: 12),
            ConversationsList(key: _conversationsKey),
          ],
        ),
      ),
    );
  }

  Widget _buildSectionHeader(String title, TextTheme textTheme) {
    return Text(title, style: textTheme.titleLarge);
  }
}

class RecentMatchesList extends StatefulWidget {
  const RecentMatchesList({super.key});

  @override
  State<RecentMatchesList> createState() => _RecentMatchesListState();
}

class _RecentMatchesListState extends State<RecentMatchesList> {
  // FIX: Changed future type to handle the full user map including UID.
  late Future<List<Map<String, dynamic>>> _recentMatchesFuture;

  @override
  void initState() {
    super.initState();
    _recentMatchesFuture = _fetchRecentMatches();
  }

  Future<List<Map<String, dynamic>>> _fetchRecentMatches() async {
    final firebaseService = Provider.of<FirebaseService>(
      context,
      listen: false,
    );
    return await firebaseService.getRecentUsers();
  }

  @override
  Widget build(BuildContext context) {
    return FutureBuilder<List<Map<String, dynamic>>>(
      future: _recentMatchesFuture,
      builder: (context, snapshot) {
        if (snapshot.connectionState == ConnectionState.waiting) {
          return const Center(child: CircularProgressIndicator());
        }
        if (snapshot.hasError) {
          return Center(child: Text("Error: ${snapshot.error}"));
        }
        if (!snapshot.hasData || snapshot.data!.isEmpty) {
          return const Center(child: Text("No recent matches"));
        }
        final matches = snapshot.data!;
        return SizedBox(
          height: 75,
          child: ListView.builder(
            scrollDirection: Axis.horizontal,
            itemCount: matches.length,
            itemBuilder: (context, index) {
              final match = matches[index];
              // FIX: Wrapped with GestureDetector to handle taps.
              return GestureDetector(
                onTap: () async {
                  final firebaseService = Provider.of<FirebaseService>(
                    context,
                    listen: false,
                  );
                  final conversation = await firebaseService
                      .getOrCreateConversation(match['uid']);
                  if (mounted) {
                    PersistentNavBarNavigator.pushNewScreen(
                      context,
                      screen: ConversationScreen(conversation: conversation),
                      withNavBar: false,
                    );
                  }
                },
                child: Padding(
                  padding: const EdgeInsets.only(right: 16.0),
                  child: Column(
                    children: [
                      CircleAvatar(
                        radius: 26,
                        backgroundImage: NetworkImage(match['avatar']!),
                      ),
                      const SizedBox(height: 6),
                      Text(
                        match['name']!,
                        style: Theme.of(context).textTheme.bodySmall,
                      ),
                    ],
                  ),
                ),
              );
            },
          ),
        );
      },
    );
  }
}

class ConversationsList extends StatelessWidget {
  const ConversationsList({super.key});

  @override
  Widget build(BuildContext context) {
    final firebaseService = Provider.of<FirebaseService>(context);
    return StreamBuilder<List<Conversation>>(
      stream: firebaseService.getConversations(),
      builder: (context, snapshot) {
        if (snapshot.connectionState == ConnectionState.waiting) {
          return const Center(child: CircularProgressIndicator());
        }
        if (snapshot.hasError) {
          return Center(child: Text('Error: ${snapshot.error}'));
        }
        if (!snapshot.hasData || snapshot.data!.isEmpty) {
          return const Center(child: Text('No conversations yet.'));
        }

        final conversations = snapshot.data!;
        return ListView.builder(
          shrinkWrap: true,
          physics: const NeverScrollableScrollPhysics(),
          itemCount: conversations.length,
          itemBuilder: (context, index) {
            final conversation = conversations[index];
            return Padding(
              padding: const EdgeInsets.only(bottom: 12.0),
              child: _buildChatItem(context, conversation),
            );
          },
        );
      },
    );
  }

  Widget _buildChatItem(BuildContext context, Conversation conversation) {
    final textTheme = Theme.of(context).textTheme;

    return GestureDetector(
      onTap: () {
        PersistentNavBarNavigator.pushNewScreen(
          context,
          screen: ConversationScreen(conversation: conversation),
          withNavBar: false,
        );
      },
      child: Row(
        children: [
          CircleAvatar(
            radius: 26,
            backgroundImage: NetworkImage(conversation.otherUser.avatarUrl),
          ),
          const SizedBox(width: 10),
          Expanded(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  conversation.otherUser.name,
                  style: textTheme.bodyMedium?.copyWith(
                    fontWeight: FontWeight.bold,
                  ),
                  maxLines: 1,
                  overflow: TextOverflow.ellipsis,
                ),
                const SizedBox(height: 4),
                Row(
                  children: [
                    const Icon(
                      Iconsax.export_2_copy,
                      size: 14,
                      color: AppColors.textSecondary,
                    ),
                    const SizedBox(width: 4),
                    Expanded(
                      child: Text(
                        conversation.lastMessage,
                        style: textTheme.bodySmall,
                        maxLines: 1,
                        overflow: TextOverflow.ellipsis,
                      ),
                    ),
                  ],
                ),
              ],
            ),
          ),
          const SizedBox(width: 10),
          Column(
            crossAxisAlignment: CrossAxisAlignment.end,
            children: [
              Text(
                TimeAgo.format(conversation.lastMessageTimestamp),
                style: textTheme.bodySmall,
              ),
              const SizedBox(height: 6),
              _buildStatusIndicator(context, conversation, textTheme),
            ],
          ),
        ],
      ),
    );
  }

  Widget _buildStatusIndicator(
    BuildContext context,
    Conversation conversation,
    TextTheme textTheme,
  ) {
    final currentUser = Provider.of<FirebaseService>(
      context,
      listen: false,
    ).currentUser;
    if (conversation.lastMessageSenderId != currentUser?.uid &&
        conversation.unreadCount > 0) {
      return Container(
        width: 20,
        height: 20,
        decoration: const BoxDecoration(
          color: AppColors.primaryRed,
          shape: BoxShape.circle,
        ),
        child: Center(
          child: Text(
            conversation.unreadCount.toString(),
            style: textTheme.bodySmall?.copyWith(
              color: Colors.white,
              fontWeight: FontWeight.bold,
            ),
          ),
        ),
      );
    } else {
      return const Icon(
        Iconsax.tick_circle_copy,
        color: AppColors.primaryRed,
        size: 18,
      );
    }
  }
}
```dart:lib/screens/dashboard/navbar_content/chats/conversation/conversation_screen.dart
import 'package:firstgenapp/models/chat_models.dart';
import 'package:firstgenapp/services/firebase_service.dart';
import 'package:firstgenapp/utils/time_ago.dart';
import 'package:flutter/material.dart';
import 'package:firstgenapp/constants/appColors.dart';
import 'package:iconly/iconly.dart';
import 'package:provider/provider.dart';

class ConversationScreen extends StatefulWidget {
  final Conversation conversation;
  const ConversationScreen({super.key, required this.conversation});

  @override
  State<ConversationScreen> createState() => _ConversationScreenState();
}

class _ConversationScreenState extends State<ConversationScreen> {
  final TextEditingController _messageController = TextEditingController();
  final ScrollController _scrollController = ScrollController();
  final FocusNode _focusNode = FocusNode();

  @override
  void initState() {
    super.initState();
    _focusNode.addListener(_onFocusChange);
    Provider.of<FirebaseService>(
      context,
      listen: false,
    ).markAsRead(widget.conversation.id);
    WidgetsBinding.instance.addPostFrameCallback((_) => _scrollToBottom(animated: false));
  }

  @override
  void dispose() {
    _messageController.dispose();
    _scrollController.dispose();
    _focusNode.removeListener(_onFocusChange);
    _focusNode.dispose();
    super.dispose();
  }

  void _onFocusChange() {
    if (_focusNode.hasFocus) {
      Future.delayed(
        const Duration(milliseconds: 300),
        () => _scrollToBottom(),
      );
    }
  }

  void _scrollToBottom({bool animated = true}) {
    if (_scrollController.hasClients) {
      final position = _scrollController.position.maxScrollExtent;
      if (animated) {
        _scrollController.animateTo(
          position,
          duration: const Duration(milliseconds: 300),
          curve: Curves.easeOut,
        );
      } else {
        _scrollController.jumpTo(position);
      }
    }
  }

  void _sendMessage() {
    final text = _messageController.text.trim();
    if (text.isNotEmpty) {
      final firebaseService = Provider.of<FirebaseService>(
        context,
        listen: false,
      );
      firebaseService.sendMessage(widget.conversation.id, text);
      _messageController.clear();
      _scrollToBottom();
    }
  }

  @override
  Widget build(BuildContext context) {
    final firebaseService = Provider.of<FirebaseService>(context);
    return Scaffold(
      backgroundColor: AppColors.secondaryBackground,
      appBar: _buildAppBar(),
      body: Column(
        children: [
          Expanded(
            child: StreamBuilder<List<ChatMessage>>(
              stream: firebaseService.getMessages(widget.conversation.id),
              builder: (context, snapshot) {
                if (snapshot.connectionState == ConnectionState.waiting) {
                  return const Center(child: CircularProgressIndicator());
                }
                if (snapshot.hasError) {
                  return Center(child: Text('Error: ${snapshot.error}'));
                }
                if (!snapshot.hasData || snapshot.data!.isEmpty) {
                  return const Center(child: Text('No messages yet.'));
                }

                final messages = snapshot.data!;

                return ListView.builder(
                  controller: _scrollController,
                  padding: const EdgeInsets.symmetric(
                    horizontal: 16.0,
                    vertical: 20.0,
                  ),
                  itemCount: messages.length,
                  itemBuilder: (context, index) {
                    final message = messages[index];
                    final showDateSeparator =
                        index == 0 ||
                        TimeAgo.formatDateSeparator(message.timestamp) !=
                            TimeAgo.formatDateSeparator(
                              messages[index - 1].timestamp,
                            );

                    return Column(
                      children: [
                        if (showDateSeparator)
                          _buildDateSeparator(
                            TimeAgo.formatDateSeparator(message.timestamp),
                          ),
                        _buildMessageBubble(message),
                      ],
                    );
                  },
                );
              },
            ),
          ),
          _buildMessageComposer(),
        ],
      ),
    );
  }

  AppBar _buildAppBar() {
    return AppBar(
      backgroundColor: AppColors.primaryBackground,
      elevation: 0,
      scrolledUnderElevation: 0,
      leading: IconButton(
        icon: const Icon(Icons.arrow_back, color: AppColors.textSecondary),
        onPressed: () => Navigator.of(context).pop(),
      ),
      title: Text(
        widget.conversation.otherUser.name,
        style: const TextStyle(
          color: AppColors.textPrimary,
          fontWeight: FontWeight.bold,
          fontSize: 18,
        ),
      ),
      centerTitle: false,
      actions: [
        IconButton(
          onPressed: () {},
          icon: const Icon(IconlyLight.video, color: AppColors.textSecondary),
        ),
        IconButton(
          onPressed: () {},
          icon: const Icon(IconlyLight.calling, color: AppColors.textSecondary),
        ),
        IconButton(
          onPressed: () {},
          icon: const Icon(Icons.more_vert, color: AppColors.textSecondary),
        ),
      ],
    );
  }

  Widget _buildDateSeparator(String date) {
    return Center(
      child: Container(
        margin: const EdgeInsets.symmetric(vertical: 16.0),
        padding: const EdgeInsets.symmetric(horizontal: 12.0, vertical: 6.0),
        decoration: BoxDecoration(
          color: Colors.grey.shade200,
          borderRadius: BorderRadius.circular(20.0),
        ),
        child: Text(
          date,
          style: const TextStyle(
            color: AppColors.textSecondary,
            fontSize: 12,
            fontWeight: FontWeight.w600,
          ),
        ),
      ),
    );
  }

  Widget _buildMessageBubble(ChatMessage message) {
    final isSender =
        message.senderId ==
        Provider.of<FirebaseService>(context, listen: false).currentUser?.uid;
    final alignment = isSender ? Alignment.centerRight : Alignment.centerLeft;
    final color = isSender ? AppColors.primaryRed : Colors.white;
    final textColor = isSender ? Colors.white : AppColors.textPrimary;
    final borderRadius = isSender
        ? const BorderRadius.only(
            topLeft: Radius.circular(20),
            topRight: Radius.circular(20),
            bottomLeft: Radius.circular(20),
          )
        : const BorderRadius.only(
            topLeft: Radius.circular(20),
            topRight: Radius.circular(20),
            bottomRight: Radius.circular(20),
          );

    return Align(
      alignment: alignment,
      child: Column(
        crossAxisAlignment: isSender
            ? CrossAxisAlignment.end
            : CrossAxisAlignment.start,
        children: [
          Container(
            constraints: BoxConstraints(
              maxWidth: MediaQuery.of(context).size.width * 0.7,
            ),
            padding: const EdgeInsets.all(12.0),
            margin: const EdgeInsets.symmetric(vertical: 4.0),
            decoration: BoxDecoration(color: color, borderRadius: borderRadius),
            child: Text(
              message.text,
              style: TextStyle(color: textColor, fontSize: 15, height: 1.4),
            ),
          ),
          const SizedBox(height: 4),
          _buildTimestampAndStatus(message, isSender),
          const SizedBox(height: 12),
        ],
      ),
    );
  }

  Widget _buildTimestampAndStatus(ChatMessage message, bool isSender) {
    return Row(
      mainAxisSize: MainAxisSize.min,
      children: [
        Text(
          TimeAgo.formatTimestamp(message.timestamp),
          style: const TextStyle(color: AppColors.textSecondary, fontSize: 12),
        ),
        if (isSender) ...[
          const SizedBox(width: 4),
          Text(
            '· Read',
            style: const TextStyle(
              color: AppColors.textSecondary,
              fontSize: 12,
            ),
          ),
        ],
      ],
    );
  }

  Widget _buildMessageComposer() {
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 12.0, vertical: 12.0),
      color: Colors.white,
      child: SafeArea(
        child: Row(
          children: [
            IconButton(
              icon: const Icon(
                Icons.add,
                color: AppColors.textSecondary,
                size: 28,
              ),
              onPressed: () {},
            ),
            Expanded(
              child: Container(
                decoration: BoxDecoration(
                  color: const Color(0xFFF5F5F7),
                  borderRadius: BorderRadius.circular(24.0),
                ),
                child: TextField(
                  controller: _messageController,
                  focusNode: _focusNode,
                  decoration: const InputDecoration(
                    hintText: 'Type a message... ',
                    border: InputBorder.none,
                    contentPadding: EdgeInsets.symmetric(
                      horizontal: 20.0,
                      vertical: 14.0,
                    ),
                  ),
                ),
              ),
            ),
            IconButton(
              icon: const Icon(
                Icons.send,
                color: AppColors.primaryRed,
                size: 28,
              ),
              onPressed: _sendMessage,
            ),
          ],
        ),
      ),
    );
  }
}
